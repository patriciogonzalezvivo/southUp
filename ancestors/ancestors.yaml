import:
    - https://tangrams.github.io/blocks/functions/map.yaml
    - https://tangrams.github.io/blocks/geometry/matrices.yaml
    - https://tangrams.github.io/blocks/shapes/rect.yaml
    - https://tangrams.github.io/blocks/shapes/cross.yaml

sources:
    ancestors:
        type: GeoJSON
        url: sources/ancestors.json

textures:
    trips:
        url: sources/trips.png

layers:
    ancestors:
        data: { source: ancestors }
        filter: { kind: trip }
        draw:
            lines:
                style: trips
                # width: [[0,.5px],[6,1px],[20,1m]]
                width: 50px
                order: 10001
                # color: [[0,[.5,.5,.5]],[20,[0,0,0]]]
                color: |
                    function(){
                        return [ ( Math.floor(feature.trip_id/255))/255, (feature.trip_id%255)/255, 0 ]; 
                    }
            # text:
            #     style: text-southup
            #     priority: 1
            #     font:
            #         family: global.font_family
            #         size: 8px
            #         fill: black
            #         stroke: { color: white, width: 2 }
    ancestors-places:
        data: { source: ancestors }
        filter: { kind: place }
        draw:
            points:
                size: [[0,0px],[10,10px]]
                color: [[0,[.7,.7,.7]], [10,[0,0,0]]]
                style: points-southup
                text:
                    style: text-southup
                    collide: true
                    font:
                        family: global.font_family
                        size: [[0,8px],[20,14px]]
                        fill: [[0,[.7,.7,.7]], [10,[0,0,0]]]
                        # stroke: { color: white, width: 3 }

styles:
    trips:
        base: lines
        mix: [lines-southup, geometry-matrices, functions-map, shapes-cross]
        # dash: [4, 2]
        lighting: false
        texcoords: true
        animated: true
        blend: overlay
        shaders:
            defines:
                PI: 3.1415926535897932384626433832795
                HALF_PI: 1.5707963267948966192313216916398
                QUATER_PI: .785398163
                TWO_PI: 6.283185307
                EARTH_RADIUS: 6378137.0
            uniforms:
                u_data: trips
                u_res: [1695, 18]
            blocks:
                global: |
                    float getIndex (vec2 encodedIndex) {
                        return (encodedIndex.x*65025.+encodedIndex.y*255.)+.5;
                    }
                    
                    float getUInt(sampler2D tex, vec2 res, float col, float row) {
                        highp vec4 value = texture2D(tex, vec2(col/res.x,1.-row/res.y));
                        return (value.x*255.)+(value.y*65025.)+(value.z*16581375.);
                    }

                    float getInt(sampler2D tex, vec2 res, float col, float row) {
                        return getUInt(tex,res,col,row)-8290688.;
                    }

                    vec3 getElements(sampler2D tex, vec2 coord) {
                        highp vec4 value = texture2D(tex, coord);
                        highp float uint = (value.x*255.)+(value.y*65025.)+(value.z*16581375.);
                        float press = ceil(value.a*255.)-244.;
                        return vec3(uint, abs(press), sign(press));
                    }

                    float getNumber(sampler2D tex, vec2 res, float col, float row) {
                        highp vec3 elements = getElements(tex, vec2(col/res.x,1.-row/res.y));
                        return elements.x * pow(10.,-floor(elements.y)) * elements.z;
                    }

                    vec2 getCoords(float index, float pct) {
                        float limit = getInt(u_data, u_res, .5, index);
                        float lon = getNumber(u_data, u_res, pct*limit, index+.5);
                        float lat = getNumber(u_data, u_res, pct*limit, index+1.5);
                        return vec2(lat, lon);
                    }
                color: |
                    // Locate the satellite
                    //===============================
                    float index = getIndex(color.st);

                    color.r = getInt(u_data, u_res, .5, index);

                    vec2 pos = getCoords(index, fract(u_time));
                    pos = (((pos*2.)-1.)*PI)*EARTH_RADIUS;
                    vec2 worldPos = u_map_position.xy+v_position.xy*-1.;
                    vec2 st = (worldPos-pos)*.0000002;

                    float z = map(u_map_position.z,0.,15.,0.,1.);
                    st *= 1.5+z*z*500.;
                    st = vec2(v_texcoord.x-.5, st.y);
                    //color.rg = st;
                    //color = vec4(1.0,0.,0.,1.)*step(.5,1.-dot(st,st)*2.);
                    


